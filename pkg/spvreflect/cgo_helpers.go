// MIT License

// WARNING: This file has automatically been generated on Tue, 10 Feb 2026 21:55:43 MSK.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package spvreflect

/*
#cgo CFLAGS: -Wno-deprecated-declarations
#include "../../internal/SPIRV-Reflect/spirv_reflect.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocNumericTraitsMemory allocates memory for type C.SpvReflectNumericTraits in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNumericTraitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNumericTraitsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNumericTraitsValue = unsafe.Sizeof([1]C.SpvReflectNumericTraits{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *NumericTraits) Ref() *C.SpvReflectNumericTraits {
	if x == nil {
		return nil
	}
	return x.ref3d621819
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *NumericTraits) Free() {
	if x != nil && x.allocs3d621819 != nil {
		x.allocs3d621819.(*cgoAllocMap).Free()
		x.ref3d621819 = nil
	}
}

// NewNumericTraitsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewNumericTraitsRef(ref unsafe.Pointer) *NumericTraits {
	if ref == nil {
		return nil
	}
	obj := new(NumericTraits)
	obj.ref3d621819 = (*C.SpvReflectNumericTraits)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *NumericTraits) PassRef() (*C.SpvReflectNumericTraits, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3d621819 != nil {
		return x.ref3d621819, nil
	}
	mem3d621819 := allocNumericTraitsMemory(1)
	ref3d621819 := (*C.SpvReflectNumericTraits)(mem3d621819)
	allocs3d621819 := new(cgoAllocMap)
	allocs3d621819.Add(mem3d621819)

	x.ref3d621819 = ref3d621819
	x.allocs3d621819 = allocs3d621819
	return ref3d621819, allocs3d621819

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x NumericTraits) PassValue() (C.SpvReflectNumericTraits, *cgoAllocMap) {
	if x.ref3d621819 != nil {
		return *x.ref3d621819, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *NumericTraits) Deref() {
	if x.ref3d621819 == nil {
		return
	}
}

// allocImageTraitsMemory allocates memory for type C.SpvReflectImageTraits in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageTraitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageTraitsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageTraitsValue = unsafe.Sizeof([1]C.SpvReflectImageTraits{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageTraits) Ref() *C.SpvReflectImageTraits {
	if x == nil {
		return nil
	}
	return x.refdb040274
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageTraits) Free() {
	if x != nil && x.allocsdb040274 != nil {
		x.allocsdb040274.(*cgoAllocMap).Free()
		x.refdb040274 = nil
	}
}

// NewImageTraitsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageTraitsRef(ref unsafe.Pointer) *ImageTraits {
	if ref == nil {
		return nil
	}
	obj := new(ImageTraits)
	obj.refdb040274 = (*C.SpvReflectImageTraits)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageTraits) PassRef() (*C.SpvReflectImageTraits, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb040274 != nil {
		return x.refdb040274, nil
	}
	memdb040274 := allocImageTraitsMemory(1)
	refdb040274 := (*C.SpvReflectImageTraits)(memdb040274)
	allocsdb040274 := new(cgoAllocMap)
	allocsdb040274.Add(memdb040274)

	var cdim_allocs *cgoAllocMap
	refdb040274.dim, cdim_allocs = (C.SpvDim)(x.Dim), cgoAllocsUnknown
	allocsdb040274.Borrow(cdim_allocs)

	var cdepth_allocs *cgoAllocMap
	refdb040274.depth, cdepth_allocs = (C.uint32_t)(x.Depth), cgoAllocsUnknown
	allocsdb040274.Borrow(cdepth_allocs)

	var carrayed_allocs *cgoAllocMap
	refdb040274.arrayed, carrayed_allocs = (C.uint32_t)(x.Arrayed), cgoAllocsUnknown
	allocsdb040274.Borrow(carrayed_allocs)

	var cms_allocs *cgoAllocMap
	refdb040274.ms, cms_allocs = (C.uint32_t)(x.Ms), cgoAllocsUnknown
	allocsdb040274.Borrow(cms_allocs)

	var csampled_allocs *cgoAllocMap
	refdb040274.sampled, csampled_allocs = (C.uint32_t)(x.Sampled), cgoAllocsUnknown
	allocsdb040274.Borrow(csampled_allocs)

	var cimage_format_allocs *cgoAllocMap
	refdb040274.image_format, cimage_format_allocs = (C.SpvImageFormat)(x.ImageFormat), cgoAllocsUnknown
	allocsdb040274.Borrow(cimage_format_allocs)

	x.refdb040274 = refdb040274
	x.allocsdb040274 = allocsdb040274
	return refdb040274, allocsdb040274

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageTraits) PassValue() (C.SpvReflectImageTraits, *cgoAllocMap) {
	if x.refdb040274 != nil {
		return *x.refdb040274, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageTraits) Deref() {
	if x.refdb040274 == nil {
		return
	}
	x.Dim = (Dim)(x.refdb040274.dim)
	x.Depth = (uint32)(x.refdb040274.depth)
	x.Arrayed = (uint32)(x.refdb040274.arrayed)
	x.Ms = (uint32)(x.refdb040274.ms)
	x.Sampled = (uint32)(x.refdb040274.sampled)
	x.ImageFormat = (ImageFormat)(x.refdb040274.image_format)
}

// allocArrayTraitsMemory allocates memory for type C.SpvReflectArrayTraits in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArrayTraitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArrayTraitsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfArrayTraitsValue = unsafe.Sizeof([1]C.SpvReflectArrayTraits{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ArrayTraits) Ref() *C.SpvReflectArrayTraits {
	if x == nil {
		return nil
	}
	return x.ref443eb8dd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ArrayTraits) Free() {
	if x != nil && x.allocs443eb8dd != nil {
		x.allocs443eb8dd.(*cgoAllocMap).Free()
		x.ref443eb8dd = nil
	}
}

// NewArrayTraitsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArrayTraitsRef(ref unsafe.Pointer) *ArrayTraits {
	if ref == nil {
		return nil
	}
	obj := new(ArrayTraits)
	obj.ref443eb8dd = (*C.SpvReflectArrayTraits)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ArrayTraits) PassRef() (*C.SpvReflectArrayTraits, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref443eb8dd != nil {
		return x.ref443eb8dd, nil
	}
	mem443eb8dd := allocArrayTraitsMemory(1)
	ref443eb8dd := (*C.SpvReflectArrayTraits)(mem443eb8dd)
	allocs443eb8dd := new(cgoAllocMap)
	allocs443eb8dd.Add(mem443eb8dd)

	var cdims_count_allocs *cgoAllocMap
	ref443eb8dd.dims_count, cdims_count_allocs = (C.uint32_t)(x.DimsCount), cgoAllocsUnknown
	allocs443eb8dd.Borrow(cdims_count_allocs)

	var cdims_allocs *cgoAllocMap
	ref443eb8dd.dims, cdims_allocs = *(*[32]C.uint32_t)(unsafe.Pointer(&x.Dims)), cgoAllocsUnknown
	allocs443eb8dd.Borrow(cdims_allocs)

	var cspec_constant_op_ids_allocs *cgoAllocMap
	ref443eb8dd.spec_constant_op_ids, cspec_constant_op_ids_allocs = *(*[32]C.uint32_t)(unsafe.Pointer(&x.SpecConstantOpIds)), cgoAllocsUnknown
	allocs443eb8dd.Borrow(cspec_constant_op_ids_allocs)

	var cstride_allocs *cgoAllocMap
	ref443eb8dd.stride, cstride_allocs = (C.uint32_t)(x.Stride), cgoAllocsUnknown
	allocs443eb8dd.Borrow(cstride_allocs)

	x.ref443eb8dd = ref443eb8dd
	x.allocs443eb8dd = allocs443eb8dd
	return ref443eb8dd, allocs443eb8dd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ArrayTraits) PassValue() (C.SpvReflectArrayTraits, *cgoAllocMap) {
	if x.ref443eb8dd != nil {
		return *x.ref443eb8dd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ArrayTraits) Deref() {
	if x.ref443eb8dd == nil {
		return
	}
	x.DimsCount = (uint32)(x.ref443eb8dd.dims_count)
	x.Dims = *(*[32]uint32)(unsafe.Pointer(&x.ref443eb8dd.dims))
	x.SpecConstantOpIds = *(*[32]uint32)(unsafe.Pointer(&x.ref443eb8dd.spec_constant_op_ids))
	x.Stride = (uint32)(x.ref443eb8dd.stride)
}

// allocBindingArrayTraitsMemory allocates memory for type C.SpvReflectBindingArrayTraits in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindingArrayTraitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindingArrayTraitsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBindingArrayTraitsValue = unsafe.Sizeof([1]C.SpvReflectBindingArrayTraits{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindingArrayTraits) Ref() *C.SpvReflectBindingArrayTraits {
	if x == nil {
		return nil
	}
	return x.ref611ee120
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindingArrayTraits) Free() {
	if x != nil && x.allocs611ee120 != nil {
		x.allocs611ee120.(*cgoAllocMap).Free()
		x.ref611ee120 = nil
	}
}

// NewBindingArrayTraitsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindingArrayTraitsRef(ref unsafe.Pointer) *BindingArrayTraits {
	if ref == nil {
		return nil
	}
	obj := new(BindingArrayTraits)
	obj.ref611ee120 = (*C.SpvReflectBindingArrayTraits)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindingArrayTraits) PassRef() (*C.SpvReflectBindingArrayTraits, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref611ee120 != nil {
		return x.ref611ee120, nil
	}
	mem611ee120 := allocBindingArrayTraitsMemory(1)
	ref611ee120 := (*C.SpvReflectBindingArrayTraits)(mem611ee120)
	allocs611ee120 := new(cgoAllocMap)
	allocs611ee120.Add(mem611ee120)

	var cdims_count_allocs *cgoAllocMap
	ref611ee120.dims_count, cdims_count_allocs = (C.uint32_t)(x.DimsCount), cgoAllocsUnknown
	allocs611ee120.Borrow(cdims_count_allocs)

	var cdims_allocs *cgoAllocMap
	ref611ee120.dims, cdims_allocs = *(*[32]C.uint32_t)(unsafe.Pointer(&x.Dims)), cgoAllocsUnknown
	allocs611ee120.Borrow(cdims_allocs)

	x.ref611ee120 = ref611ee120
	x.allocs611ee120 = allocs611ee120
	return ref611ee120, allocs611ee120

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindingArrayTraits) PassValue() (C.SpvReflectBindingArrayTraits, *cgoAllocMap) {
	if x.ref611ee120 != nil {
		return *x.ref611ee120, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindingArrayTraits) Deref() {
	if x.ref611ee120 == nil {
		return
	}
	x.DimsCount = (uint32)(x.ref611ee120.dims_count)
	x.Dims = *(*[32]uint32)(unsafe.Pointer(&x.ref611ee120.dims))
}

// allocTypeDescriptionMemory allocates memory for type C.SpvReflectTypeDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTypeDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTypeDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTypeDescriptionValue = unsafe.Sizeof([1]C.SpvReflectTypeDescription{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocStruct_SpvReflectTypeDescriptionMemory allocates memory for type C.struct_SpvReflectTypeDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_SpvReflectTypeDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_SpvReflectTypeDescriptionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStruct_SpvReflectTypeDescriptionValue = unsafe.Sizeof([1]C.struct_SpvReflectTypeDescription{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSTypeDescription transforms a sliced Go data structure into plain C format.
func unpackSTypeDescription(x []TypeDescription) (unpacked *C.struct_SpvReflectTypeDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_SpvReflectTypeDescription) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_SpvReflectTypeDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_SpvReflectTypeDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_SpvReflectTypeDescription)(h.Data)
	return
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// packSTypeDescription reads sliced Go data structure out from plain C format.
func packSTypeDescription(v []TypeDescription, ptr0 *C.struct_SpvReflectTypeDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_SpvReflectTypeDescriptionValue]C.struct_SpvReflectTypeDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTypeDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TypeDescription) Ref() *C.SpvReflectTypeDescription {
	if x == nil {
		return nil
	}
	return x.ref1250b8c8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TypeDescription) Free() {
	if x != nil && x.allocs1250b8c8 != nil {
		x.allocs1250b8c8.(*cgoAllocMap).Free()
		x.ref1250b8c8 = nil
	}
}

// NewTypeDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTypeDescriptionRef(ref unsafe.Pointer) *TypeDescription {
	if ref == nil {
		return nil
	}
	obj := new(TypeDescription)
	obj.ref1250b8c8 = (*C.SpvReflectTypeDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TypeDescription) PassRef() (*C.SpvReflectTypeDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1250b8c8 != nil {
		return x.ref1250b8c8, nil
	}
	mem1250b8c8 := allocTypeDescriptionMemory(1)
	ref1250b8c8 := (*C.SpvReflectTypeDescription)(mem1250b8c8)
	allocs1250b8c8 := new(cgoAllocMap)
	allocs1250b8c8.Add(mem1250b8c8)

	var cid_allocs *cgoAllocMap
	ref1250b8c8.id, cid_allocs = (C.uint32_t)(x.Id), cgoAllocsUnknown
	allocs1250b8c8.Borrow(cid_allocs)

	var cop_allocs *cgoAllocMap
	ref1250b8c8.op, cop_allocs = (C.SpvOp)(x.Op), cgoAllocsUnknown
	allocs1250b8c8.Borrow(cop_allocs)

	var ctype_name_allocs *cgoAllocMap
	ref1250b8c8.type_name, ctype_name_allocs = unpackPCharString(x.TypeName)
	allocs1250b8c8.Borrow(ctype_name_allocs)

	var cstruct_member_name_allocs *cgoAllocMap
	ref1250b8c8.struct_member_name, cstruct_member_name_allocs = unpackPCharString(x.StructMemberName)
	allocs1250b8c8.Borrow(cstruct_member_name_allocs)

	var cstorage_class_allocs *cgoAllocMap
	ref1250b8c8.storage_class, cstorage_class_allocs = (C.int)(x.StorageClass), cgoAllocsUnknown
	allocs1250b8c8.Borrow(cstorage_class_allocs)

	var ctype_flags_allocs *cgoAllocMap
	ref1250b8c8.type_flags, ctype_flags_allocs = (C.SpvReflectTypeFlags)(x.TypeFlags), cgoAllocsUnknown
	allocs1250b8c8.Borrow(ctype_flags_allocs)

	var cdecoration_flags_allocs *cgoAllocMap
	ref1250b8c8.decoration_flags, cdecoration_flags_allocs = (C.SpvReflectDecorationFlags)(x.DecorationFlags), cgoAllocsUnknown
	allocs1250b8c8.Borrow(cdecoration_flags_allocs)

	var cstruct_type_description_allocs *cgoAllocMap
	ref1250b8c8.struct_type_description, cstruct_type_description_allocs = unpackSTypeDescription(x.StructTypeDescription)
	allocs1250b8c8.Borrow(cstruct_type_description_allocs)

	var ccopied_allocs *cgoAllocMap
	ref1250b8c8.copied, ccopied_allocs = (C.uint32_t)(x.Copied), cgoAllocsUnknown
	allocs1250b8c8.Borrow(ccopied_allocs)

	var cmember_count_allocs *cgoAllocMap
	ref1250b8c8.member_count, cmember_count_allocs = (C.uint32_t)(x.MemberCount), cgoAllocsUnknown
	allocs1250b8c8.Borrow(cmember_count_allocs)

	var cmembers_allocs *cgoAllocMap
	ref1250b8c8.members, cmembers_allocs = unpackSTypeDescription(x.Members)
	allocs1250b8c8.Borrow(cmembers_allocs)

	x.ref1250b8c8 = ref1250b8c8
	x.allocs1250b8c8 = allocs1250b8c8
	return ref1250b8c8, allocs1250b8c8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TypeDescription) PassValue() (C.SpvReflectTypeDescription, *cgoAllocMap) {
	if x.ref1250b8c8 != nil {
		return *x.ref1250b8c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TypeDescription) Deref() {
	if x.ref1250b8c8 == nil {
		return
	}
	x.Id = (uint32)(x.ref1250b8c8.id)
	x.Op = (Op)(x.ref1250b8c8.op)
	x.TypeName = packPCharString(x.ref1250b8c8.type_name)
	x.StructMemberName = packPCharString(x.ref1250b8c8.struct_member_name)
	x.StorageClass = (int32)(x.ref1250b8c8.storage_class)
	x.TypeFlags = (TypeFlags)(x.ref1250b8c8.type_flags)
	x.DecorationFlags = (DecorationFlags)(x.ref1250b8c8.decoration_flags)
	packSTypeDescription(x.StructTypeDescription, x.ref1250b8c8.struct_type_description)
	x.Copied = (uint32)(x.ref1250b8c8.copied)
	x.MemberCount = (uint32)(x.ref1250b8c8.member_count)
	packSTypeDescription(x.Members, x.ref1250b8c8.members)
}

// allocInterfaceVariableMemory allocates memory for type C.SpvReflectInterfaceVariable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInterfaceVariableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInterfaceVariableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfInterfaceVariableValue = unsafe.Sizeof([1]C.SpvReflectInterfaceVariable{})

// allocStruct_SpvReflectInterfaceVariableMemory allocates memory for type C.struct_SpvReflectInterfaceVariable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_SpvReflectInterfaceVariableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_SpvReflectInterfaceVariableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStruct_SpvReflectInterfaceVariableValue = unsafe.Sizeof([1]C.struct_SpvReflectInterfaceVariable{})

// unpackSInterfaceVariable transforms a sliced Go data structure into plain C format.
func unpackSInterfaceVariable(x []InterfaceVariable) (unpacked *C.struct_SpvReflectInterfaceVariable, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_SpvReflectInterfaceVariable) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_SpvReflectInterfaceVariableMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_SpvReflectInterfaceVariable)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_SpvReflectInterfaceVariable)(h.Data)
	return
}

// packSInterfaceVariable reads sliced Go data structure out from plain C format.
func packSInterfaceVariable(v []InterfaceVariable, ptr0 *C.struct_SpvReflectInterfaceVariable) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_SpvReflectInterfaceVariableValue]C.struct_SpvReflectInterfaceVariable)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewInterfaceVariableRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *InterfaceVariable) Ref() *C.SpvReflectInterfaceVariable {
	if x == nil {
		return nil
	}
	return x.refab7c479d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *InterfaceVariable) Free() {
	if x != nil && x.allocsab7c479d != nil {
		x.allocsab7c479d.(*cgoAllocMap).Free()
		x.refab7c479d = nil
	}
}

// NewInterfaceVariableRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInterfaceVariableRef(ref unsafe.Pointer) *InterfaceVariable {
	if ref == nil {
		return nil
	}
	obj := new(InterfaceVariable)
	obj.refab7c479d = (*C.SpvReflectInterfaceVariable)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *InterfaceVariable) PassRef() (*C.SpvReflectInterfaceVariable, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refab7c479d != nil {
		return x.refab7c479d, nil
	}
	memab7c479d := allocInterfaceVariableMemory(1)
	refab7c479d := (*C.SpvReflectInterfaceVariable)(memab7c479d)
	allocsab7c479d := new(cgoAllocMap)
	allocsab7c479d.Add(memab7c479d)

	var cspirv_id_allocs *cgoAllocMap
	refab7c479d.spirv_id, cspirv_id_allocs = (C.uint32_t)(x.SpirvId), cgoAllocsUnknown
	allocsab7c479d.Borrow(cspirv_id_allocs)

	var cname_allocs *cgoAllocMap
	refab7c479d.name, cname_allocs = unpackPCharString(x.Name)
	allocsab7c479d.Borrow(cname_allocs)

	var clocation_allocs *cgoAllocMap
	refab7c479d.location, clocation_allocs = (C.uint32_t)(x.Location), cgoAllocsUnknown
	allocsab7c479d.Borrow(clocation_allocs)

	var ccomponent_allocs *cgoAllocMap
	refab7c479d.component, ccomponent_allocs = (C.uint32_t)(x.Component), cgoAllocsUnknown
	allocsab7c479d.Borrow(ccomponent_allocs)

	var cstorage_class_allocs *cgoAllocMap
	refab7c479d.storage_class, cstorage_class_allocs = (C.SpvStorageClass)(x.StorageClass), cgoAllocsUnknown
	allocsab7c479d.Borrow(cstorage_class_allocs)

	var csemantic_allocs *cgoAllocMap
	refab7c479d.semantic, csemantic_allocs = unpackPCharString(x.Semantic)
	allocsab7c479d.Borrow(csemantic_allocs)

	var cdecoration_flags_allocs *cgoAllocMap
	refab7c479d.decoration_flags, cdecoration_flags_allocs = (C.SpvReflectDecorationFlags)(x.DecorationFlags), cgoAllocsUnknown
	allocsab7c479d.Borrow(cdecoration_flags_allocs)

	var cbuilt_in_allocs *cgoAllocMap
	refab7c479d.built_in, cbuilt_in_allocs = (C.int)(x.BuiltIn), cgoAllocsUnknown
	allocsab7c479d.Borrow(cbuilt_in_allocs)

	var cnumeric_allocs *cgoAllocMap
	refab7c479d.numeric, cnumeric_allocs = x.Numeric.PassValue()
	allocsab7c479d.Borrow(cnumeric_allocs)

	var carray_allocs *cgoAllocMap
	refab7c479d.array, carray_allocs = x.Array.PassValue()
	allocsab7c479d.Borrow(carray_allocs)

	var cmember_count_allocs *cgoAllocMap
	refab7c479d.member_count, cmember_count_allocs = (C.uint32_t)(x.MemberCount), cgoAllocsUnknown
	allocsab7c479d.Borrow(cmember_count_allocs)

	var cmembers_allocs *cgoAllocMap
	refab7c479d.members, cmembers_allocs = unpackSInterfaceVariable(x.Members)
	allocsab7c479d.Borrow(cmembers_allocs)

	var cformat_allocs *cgoAllocMap
	refab7c479d.format, cformat_allocs = (C.SpvReflectFormat)(x.Format), cgoAllocsUnknown
	allocsab7c479d.Borrow(cformat_allocs)

	var ctype_description_allocs *cgoAllocMap
	refab7c479d.type_description, ctype_description_allocs = unpackSTypeDescription(x.TypeDescription)
	allocsab7c479d.Borrow(ctype_description_allocs)

	x.refab7c479d = refab7c479d
	x.allocsab7c479d = allocsab7c479d
	return refab7c479d, allocsab7c479d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x InterfaceVariable) PassValue() (C.SpvReflectInterfaceVariable, *cgoAllocMap) {
	if x.refab7c479d != nil {
		return *x.refab7c479d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *InterfaceVariable) Deref() {
	if x.refab7c479d == nil {
		return
	}
	x.SpirvId = (uint32)(x.refab7c479d.spirv_id)
	x.Name = packPCharString(x.refab7c479d.name)
	x.Location = (uint32)(x.refab7c479d.location)
	x.Component = (uint32)(x.refab7c479d.component)
	x.StorageClass = (StorageClass)(x.refab7c479d.storage_class)
	x.Semantic = packPCharString(x.refab7c479d.semantic)
	x.DecorationFlags = (DecorationFlags)(x.refab7c479d.decoration_flags)
	x.BuiltIn = (int32)(x.refab7c479d.built_in)
	x.Numeric = *NewNumericTraitsRef(unsafe.Pointer(&x.refab7c479d.numeric))
	x.Array = *NewArrayTraitsRef(unsafe.Pointer(&x.refab7c479d.array))
	x.MemberCount = (uint32)(x.refab7c479d.member_count)
	packSInterfaceVariable(x.Members, x.refab7c479d.members)
	x.Format = (Format)(x.refab7c479d.format)
	packSTypeDescription(x.TypeDescription, x.refab7c479d.type_description)
}

// allocBlockVariableMemory allocates memory for type C.SpvReflectBlockVariable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBlockVariableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBlockVariableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBlockVariableValue = unsafe.Sizeof([1]C.SpvReflectBlockVariable{})

// allocStruct_SpvReflectBlockVariableMemory allocates memory for type C.struct_SpvReflectBlockVariable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_SpvReflectBlockVariableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_SpvReflectBlockVariableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStruct_SpvReflectBlockVariableValue = unsafe.Sizeof([1]C.struct_SpvReflectBlockVariable{})

// unpackSBlockVariable transforms a sliced Go data structure into plain C format.
func unpackSBlockVariable(x []BlockVariable) (unpacked *C.struct_SpvReflectBlockVariable, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_SpvReflectBlockVariable) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_SpvReflectBlockVariableMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_SpvReflectBlockVariable)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_SpvReflectBlockVariable)(h.Data)
	return
}

// packSBlockVariable reads sliced Go data structure out from plain C format.
func packSBlockVariable(v []BlockVariable, ptr0 *C.struct_SpvReflectBlockVariable) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_SpvReflectBlockVariableValue]C.struct_SpvReflectBlockVariable)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBlockVariableRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BlockVariable) Ref() *C.SpvReflectBlockVariable {
	if x == nil {
		return nil
	}
	return x.ref1455998a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BlockVariable) Free() {
	if x != nil && x.allocs1455998a != nil {
		x.allocs1455998a.(*cgoAllocMap).Free()
		x.ref1455998a = nil
	}
}

// NewBlockVariableRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBlockVariableRef(ref unsafe.Pointer) *BlockVariable {
	if ref == nil {
		return nil
	}
	obj := new(BlockVariable)
	obj.ref1455998a = (*C.SpvReflectBlockVariable)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BlockVariable) PassRef() (*C.SpvReflectBlockVariable, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1455998a != nil {
		return x.ref1455998a, nil
	}
	mem1455998a := allocBlockVariableMemory(1)
	ref1455998a := (*C.SpvReflectBlockVariable)(mem1455998a)
	allocs1455998a := new(cgoAllocMap)
	allocs1455998a.Add(mem1455998a)

	var cspirv_id_allocs *cgoAllocMap
	ref1455998a.spirv_id, cspirv_id_allocs = (C.uint32_t)(x.SpirvId), cgoAllocsUnknown
	allocs1455998a.Borrow(cspirv_id_allocs)

	var cname_allocs *cgoAllocMap
	ref1455998a.name, cname_allocs = unpackPCharString(x.Name)
	allocs1455998a.Borrow(cname_allocs)

	var coffset_allocs *cgoAllocMap
	ref1455998a.offset, coffset_allocs = (C.uint32_t)(x.Offset), cgoAllocsUnknown
	allocs1455998a.Borrow(coffset_allocs)

	var cabsolute_offset_allocs *cgoAllocMap
	ref1455998a.absolute_offset, cabsolute_offset_allocs = (C.uint32_t)(x.AbsoluteOffset), cgoAllocsUnknown
	allocs1455998a.Borrow(cabsolute_offset_allocs)

	var csize_allocs *cgoAllocMap
	ref1455998a.size, csize_allocs = (C.uint32_t)(x.Size), cgoAllocsUnknown
	allocs1455998a.Borrow(csize_allocs)

	var cpadded_size_allocs *cgoAllocMap
	ref1455998a.padded_size, cpadded_size_allocs = (C.uint32_t)(x.PaddedSize), cgoAllocsUnknown
	allocs1455998a.Borrow(cpadded_size_allocs)

	var cdecoration_flags_allocs *cgoAllocMap
	ref1455998a.decoration_flags, cdecoration_flags_allocs = (C.SpvReflectDecorationFlags)(x.DecorationFlags), cgoAllocsUnknown
	allocs1455998a.Borrow(cdecoration_flags_allocs)

	var cnumeric_allocs *cgoAllocMap
	ref1455998a.numeric, cnumeric_allocs = x.Numeric.PassValue()
	allocs1455998a.Borrow(cnumeric_allocs)

	var carray_allocs *cgoAllocMap
	ref1455998a.array, carray_allocs = x.Array.PassValue()
	allocs1455998a.Borrow(carray_allocs)

	var cflags_allocs *cgoAllocMap
	ref1455998a.flags, cflags_allocs = (C.SpvReflectVariableFlags)(x.Flags), cgoAllocsUnknown
	allocs1455998a.Borrow(cflags_allocs)

	var cmember_count_allocs *cgoAllocMap
	ref1455998a.member_count, cmember_count_allocs = (C.uint32_t)(x.MemberCount), cgoAllocsUnknown
	allocs1455998a.Borrow(cmember_count_allocs)

	var cmembers_allocs *cgoAllocMap
	ref1455998a.members, cmembers_allocs = unpackSBlockVariable(x.Members)
	allocs1455998a.Borrow(cmembers_allocs)

	var ctype_description_allocs *cgoAllocMap
	ref1455998a.type_description, ctype_description_allocs = unpackSTypeDescription(x.TypeDescription)
	allocs1455998a.Borrow(ctype_description_allocs)

	x.ref1455998a = ref1455998a
	x.allocs1455998a = allocs1455998a
	return ref1455998a, allocs1455998a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BlockVariable) PassValue() (C.SpvReflectBlockVariable, *cgoAllocMap) {
	if x.ref1455998a != nil {
		return *x.ref1455998a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BlockVariable) Deref() {
	if x.ref1455998a == nil {
		return
	}
	x.SpirvId = (uint32)(x.ref1455998a.spirv_id)
	x.Name = packPCharString(x.ref1455998a.name)
	x.Offset = (uint32)(x.ref1455998a.offset)
	x.AbsoluteOffset = (uint32)(x.ref1455998a.absolute_offset)
	x.Size = (uint32)(x.ref1455998a.size)
	x.PaddedSize = (uint32)(x.ref1455998a.padded_size)
	x.DecorationFlags = (DecorationFlags)(x.ref1455998a.decoration_flags)
	x.Numeric = *NewNumericTraitsRef(unsafe.Pointer(&x.ref1455998a.numeric))
	x.Array = *NewArrayTraitsRef(unsafe.Pointer(&x.ref1455998a.array))
	x.Flags = (VariableFlags)(x.ref1455998a.flags)
	x.MemberCount = (uint32)(x.ref1455998a.member_count)
	packSBlockVariable(x.Members, x.ref1455998a.members)
	packSTypeDescription(x.TypeDescription, x.ref1455998a.type_description)
}

// allocDescriptorBindingMemory allocates memory for type C.SpvReflectDescriptorBinding in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorBindingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorBindingValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorBindingValue = unsafe.Sizeof([1]C.SpvReflectDescriptorBinding{})

// allocStruct_SpvReflectDescriptorBindingMemory allocates memory for type C.struct_SpvReflectDescriptorBinding in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_SpvReflectDescriptorBindingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_SpvReflectDescriptorBindingValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStruct_SpvReflectDescriptorBindingValue = unsafe.Sizeof([1]C.struct_SpvReflectDescriptorBinding{})

// unpackSDescriptorBinding transforms a sliced Go data structure into plain C format.
func unpackSDescriptorBinding(x []DescriptorBinding) (unpacked *C.struct_SpvReflectDescriptorBinding, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_SpvReflectDescriptorBinding) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_SpvReflectDescriptorBindingMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_SpvReflectDescriptorBinding)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_SpvReflectDescriptorBinding)(h.Data)
	return
}

// packSDescriptorBinding reads sliced Go data structure out from plain C format.
func packSDescriptorBinding(v []DescriptorBinding, ptr0 *C.struct_SpvReflectDescriptorBinding) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_SpvReflectDescriptorBindingValue]C.struct_SpvReflectDescriptorBinding)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorBindingRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorBinding) Ref() *C.SpvReflectDescriptorBinding {
	if x == nil {
		return nil
	}
	return x.ref72816273
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorBinding) Free() {
	if x != nil && x.allocs72816273 != nil {
		x.allocs72816273.(*cgoAllocMap).Free()
		x.ref72816273 = nil
	}
}

// NewDescriptorBindingRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorBindingRef(ref unsafe.Pointer) *DescriptorBinding {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorBinding)
	obj.ref72816273 = (*C.SpvReflectDescriptorBinding)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorBinding) PassRef() (*C.SpvReflectDescriptorBinding, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref72816273 != nil {
		return x.ref72816273, nil
	}
	mem72816273 := allocDescriptorBindingMemory(1)
	ref72816273 := (*C.SpvReflectDescriptorBinding)(mem72816273)
	allocs72816273 := new(cgoAllocMap)
	allocs72816273.Add(mem72816273)

	var cspirv_id_allocs *cgoAllocMap
	ref72816273.spirv_id, cspirv_id_allocs = (C.uint32_t)(x.SpirvId), cgoAllocsUnknown
	allocs72816273.Borrow(cspirv_id_allocs)

	var cname_allocs *cgoAllocMap
	ref72816273.name, cname_allocs = unpackPCharString(x.Name)
	allocs72816273.Borrow(cname_allocs)

	var cbinding_allocs *cgoAllocMap
	ref72816273.binding, cbinding_allocs = (C.uint32_t)(x.Binding), cgoAllocsUnknown
	allocs72816273.Borrow(cbinding_allocs)

	var cinput_attachment_index_allocs *cgoAllocMap
	ref72816273.input_attachment_index, cinput_attachment_index_allocs = (C.uint32_t)(x.InputAttachmentIndex), cgoAllocsUnknown
	allocs72816273.Borrow(cinput_attachment_index_allocs)

	var cset_allocs *cgoAllocMap
	ref72816273.set, cset_allocs = (C.uint32_t)(x.Set), cgoAllocsUnknown
	allocs72816273.Borrow(cset_allocs)

	var cdescriptor_type_allocs *cgoAllocMap
	ref72816273.descriptor_type, cdescriptor_type_allocs = (C.SpvReflectDescriptorType)(x.DescriptorType), cgoAllocsUnknown
	allocs72816273.Borrow(cdescriptor_type_allocs)

	var cresource_type_allocs *cgoAllocMap
	ref72816273.resource_type, cresource_type_allocs = (C.SpvReflectResourceType)(x.ResourceType), cgoAllocsUnknown
	allocs72816273.Borrow(cresource_type_allocs)

	var cimage_allocs *cgoAllocMap
	ref72816273.image, cimage_allocs = x.Image.PassValue()
	allocs72816273.Borrow(cimage_allocs)

	var cblock_allocs *cgoAllocMap
	ref72816273.block, cblock_allocs = x.Block.PassValue()
	allocs72816273.Borrow(cblock_allocs)

	var carray_allocs *cgoAllocMap
	ref72816273.array, carray_allocs = x.Array.PassValue()
	allocs72816273.Borrow(carray_allocs)

	var ccount_allocs *cgoAllocMap
	ref72816273.count, ccount_allocs = (C.uint32_t)(x.Count), cgoAllocsUnknown
	allocs72816273.Borrow(ccount_allocs)

	var caccessed_allocs *cgoAllocMap
	ref72816273.accessed, caccessed_allocs = (C.uint32_t)(x.Accessed), cgoAllocsUnknown
	allocs72816273.Borrow(caccessed_allocs)

	var cuav_counter_id_allocs *cgoAllocMap
	ref72816273.uav_counter_id, cuav_counter_id_allocs = (C.uint32_t)(x.UavCounterId), cgoAllocsUnknown
	allocs72816273.Borrow(cuav_counter_id_allocs)

	var cuav_counter_binding_allocs *cgoAllocMap
	ref72816273.uav_counter_binding, cuav_counter_binding_allocs = unpackSDescriptorBinding(x.UavCounterBinding)
	allocs72816273.Borrow(cuav_counter_binding_allocs)

	var cbyte_address_buffer_offset_count_allocs *cgoAllocMap
	ref72816273.byte_address_buffer_offset_count, cbyte_address_buffer_offset_count_allocs = (C.uint32_t)(x.ByteAddressBufferOffsetCount), cgoAllocsUnknown
	allocs72816273.Borrow(cbyte_address_buffer_offset_count_allocs)

	var cbyte_address_buffer_offsets_allocs *cgoAllocMap
	ref72816273.byte_address_buffer_offsets, cbyte_address_buffer_offsets_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.ByteAddressBufferOffsets)).Data)), cgoAllocsUnknown
	allocs72816273.Borrow(cbyte_address_buffer_offsets_allocs)

	var ctype_description_allocs *cgoAllocMap
	ref72816273.type_description, ctype_description_allocs = unpackSTypeDescription(x.TypeDescription)
	allocs72816273.Borrow(ctype_description_allocs)

	var cdecoration_flags_allocs *cgoAllocMap
	ref72816273.decoration_flags, cdecoration_flags_allocs = (C.SpvReflectDecorationFlags)(x.DecorationFlags), cgoAllocsUnknown
	allocs72816273.Borrow(cdecoration_flags_allocs)

	var cuser_type_allocs *cgoAllocMap
	ref72816273.user_type, cuser_type_allocs = (C.SpvReflectUserType)(x.UserType), cgoAllocsUnknown
	allocs72816273.Borrow(cuser_type_allocs)

	x.ref72816273 = ref72816273
	x.allocs72816273 = allocs72816273
	return ref72816273, allocs72816273

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorBinding) PassValue() (C.SpvReflectDescriptorBinding, *cgoAllocMap) {
	if x.ref72816273 != nil {
		return *x.ref72816273, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorBinding) Deref() {
	if x.ref72816273 == nil {
		return
	}
	x.SpirvId = (uint32)(x.ref72816273.spirv_id)
	x.Name = packPCharString(x.ref72816273.name)
	x.Binding = (uint32)(x.ref72816273.binding)
	x.InputAttachmentIndex = (uint32)(x.ref72816273.input_attachment_index)
	x.Set = (uint32)(x.ref72816273.set)
	x.DescriptorType = (DescriptorType)(x.ref72816273.descriptor_type)
	x.ResourceType = (ResourceType)(x.ref72816273.resource_type)
	x.Image = *NewImageTraitsRef(unsafe.Pointer(&x.ref72816273.image))
	x.Block = *NewBlockVariableRef(unsafe.Pointer(&x.ref72816273.block))
	x.Array = *NewBindingArrayTraitsRef(unsafe.Pointer(&x.ref72816273.array))
	x.Count = (uint32)(x.ref72816273.count)
	x.Accessed = (uint32)(x.ref72816273.accessed)
	x.UavCounterId = (uint32)(x.ref72816273.uav_counter_id)
	packSDescriptorBinding(x.UavCounterBinding, x.ref72816273.uav_counter_binding)
	x.ByteAddressBufferOffsetCount = (uint32)(x.ref72816273.byte_address_buffer_offset_count)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.ByteAddressBufferOffsets))
	hxfc4425b.Data = unsafe.Pointer(x.ref72816273.byte_address_buffer_offsets)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	packSTypeDescription(x.TypeDescription, x.ref72816273.type_description)
	x.DecorationFlags = (DecorationFlags)(x.ref72816273.decoration_flags)
	x.UserType = (UserType)(x.ref72816273.user_type)
}

// allocDescriptorSetMemory allocates memory for type C.SpvReflectDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDescriptorSetValue = unsafe.Sizeof([1]C.SpvReflectDescriptorSet{})

// allocPDescriptorBindingMemory allocates memory for type *C.SpvReflectDescriptorBinding in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDescriptorBindingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDescriptorBindingValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDescriptorBindingValue = unsafe.Sizeof([1]*C.SpvReflectDescriptorBinding{})

// unpackSSDescriptorBinding transforms a sliced Go data structure into plain C format.
func unpackSSDescriptorBinding(x [][]DescriptorBinding) (unpacked **C.SpvReflectDescriptorBinding, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.SpvReflectDescriptorBinding) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPDescriptorBindingMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.SpvReflectDescriptorBinding)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocDescriptorBindingMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.SpvReflectDescriptorBinding)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.SpvReflectDescriptorBinding)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.SpvReflectDescriptorBinding)(h.Data)
	return
}

// packSSDescriptorBinding reads sliced Go data structure out from plain C format.
func packSSDescriptorBinding(v [][]DescriptorBinding, ptr0 **C.SpvReflectDescriptorBinding) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.SpvReflectDescriptorBinding)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfDescriptorBindingValue]C.SpvReflectDescriptorBinding)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewDescriptorBindingRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSet) Ref() *C.SpvReflectDescriptorSet {
	if x == nil {
		return nil
	}
	return x.ref95bcf29b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSet) Free() {
	if x != nil && x.allocs95bcf29b != nil {
		x.allocs95bcf29b.(*cgoAllocMap).Free()
		x.ref95bcf29b = nil
	}
}

// NewDescriptorSetRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetRef(ref unsafe.Pointer) *DescriptorSet {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSet)
	obj.ref95bcf29b = (*C.SpvReflectDescriptorSet)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSet) PassRef() (*C.SpvReflectDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref95bcf29b != nil {
		return x.ref95bcf29b, nil
	}
	mem95bcf29b := allocDescriptorSetMemory(1)
	ref95bcf29b := (*C.SpvReflectDescriptorSet)(mem95bcf29b)
	allocs95bcf29b := new(cgoAllocMap)
	allocs95bcf29b.Add(mem95bcf29b)

	var cset_allocs *cgoAllocMap
	ref95bcf29b.set, cset_allocs = (C.uint32_t)(x.Set), cgoAllocsUnknown
	allocs95bcf29b.Borrow(cset_allocs)

	var cbinding_count_allocs *cgoAllocMap
	ref95bcf29b.binding_count, cbinding_count_allocs = (C.uint32_t)(x.BindingCount), cgoAllocsUnknown
	allocs95bcf29b.Borrow(cbinding_count_allocs)

	var cbindings_allocs *cgoAllocMap
	ref95bcf29b.bindings, cbindings_allocs = unpackSSDescriptorBinding(x.Bindings)
	allocs95bcf29b.Borrow(cbindings_allocs)

	x.ref95bcf29b = ref95bcf29b
	x.allocs95bcf29b = allocs95bcf29b
	return ref95bcf29b, allocs95bcf29b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSet) PassValue() (C.SpvReflectDescriptorSet, *cgoAllocMap) {
	if x.ref95bcf29b != nil {
		return *x.ref95bcf29b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSet) Deref() {
	if x.ref95bcf29b == nil {
		return
	}
	x.Set = (uint32)(x.ref95bcf29b.set)
	x.BindingCount = (uint32)(x.ref95bcf29b.binding_count)
	packSSDescriptorBinding(x.Bindings, x.ref95bcf29b.bindings)
}

// allocEntryPointMemory allocates memory for type C.SpvReflectEntryPoint in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEntryPointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEntryPointValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEntryPointValue = unsafe.Sizeof([1]C.SpvReflectEntryPoint{})

// allocPInterfaceVariableMemory allocates memory for type *C.SpvReflectInterfaceVariable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPInterfaceVariableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPInterfaceVariableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPInterfaceVariableValue = unsafe.Sizeof([1]*C.SpvReflectInterfaceVariable{})

// unpackSSInterfaceVariable transforms a sliced Go data structure into plain C format.
func unpackSSInterfaceVariable(x [][]InterfaceVariable) (unpacked **C.SpvReflectInterfaceVariable, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.SpvReflectInterfaceVariable) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPInterfaceVariableMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.SpvReflectInterfaceVariable)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocInterfaceVariableMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.SpvReflectInterfaceVariable)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.SpvReflectInterfaceVariable)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.SpvReflectInterfaceVariable)(h.Data)
	return
}

// unpackSDescriptorSet transforms a sliced Go data structure into plain C format.
func unpackSDescriptorSet(x []DescriptorSet) (unpacked *C.SpvReflectDescriptorSet, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.SpvReflectDescriptorSet) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.SpvReflectDescriptorSet)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.SpvReflectDescriptorSet)(h.Data)
	return
}

// packSSInterfaceVariable reads sliced Go data structure out from plain C format.
func packSSInterfaceVariable(v [][]InterfaceVariable, ptr0 **C.SpvReflectInterfaceVariable) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.SpvReflectInterfaceVariable)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfInterfaceVariableValue]C.SpvReflectInterfaceVariable)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewInterfaceVariableRef(unsafe.Pointer(&ptr2))
		}
	}
}

// packSDescriptorSet reads sliced Go data structure out from plain C format.
func packSDescriptorSet(v []DescriptorSet, ptr0 *C.SpvReflectDescriptorSet) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorSetValue]C.SpvReflectDescriptorSet)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorSetRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EntryPoint) Ref() *C.SpvReflectEntryPoint {
	if x == nil {
		return nil
	}
	return x.reff018ae0f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EntryPoint) Free() {
	if x != nil && x.allocsf018ae0f != nil {
		x.allocsf018ae0f.(*cgoAllocMap).Free()
		x.reff018ae0f = nil
	}
}

// NewEntryPointRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEntryPointRef(ref unsafe.Pointer) *EntryPoint {
	if ref == nil {
		return nil
	}
	obj := new(EntryPoint)
	obj.reff018ae0f = (*C.SpvReflectEntryPoint)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EntryPoint) PassRef() (*C.SpvReflectEntryPoint, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff018ae0f != nil {
		return x.reff018ae0f, nil
	}
	memf018ae0f := allocEntryPointMemory(1)
	reff018ae0f := (*C.SpvReflectEntryPoint)(memf018ae0f)
	allocsf018ae0f := new(cgoAllocMap)
	allocsf018ae0f.Add(memf018ae0f)

	var cname_allocs *cgoAllocMap
	reff018ae0f.name, cname_allocs = unpackPCharString(x.Name)
	allocsf018ae0f.Borrow(cname_allocs)

	var cid_allocs *cgoAllocMap
	reff018ae0f.id, cid_allocs = (C.uint32_t)(x.Id), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cid_allocs)

	var cspirv_execution_model_allocs *cgoAllocMap
	reff018ae0f.spirv_execution_model, cspirv_execution_model_allocs = (C.SpvExecutionModel)(x.SpirvExecutionModel), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cspirv_execution_model_allocs)

	var cshader_stage_allocs *cgoAllocMap
	reff018ae0f.shader_stage, cshader_stage_allocs = (C.SpvReflectShaderStageFlagBits)(x.ShaderStage), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cshader_stage_allocs)

	var cinput_variable_count_allocs *cgoAllocMap
	reff018ae0f.input_variable_count, cinput_variable_count_allocs = (C.uint32_t)(x.InputVariableCount), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cinput_variable_count_allocs)

	var cinput_variables_allocs *cgoAllocMap
	reff018ae0f.input_variables, cinput_variables_allocs = unpackSSInterfaceVariable(x.InputVariables)
	allocsf018ae0f.Borrow(cinput_variables_allocs)

	var coutput_variable_count_allocs *cgoAllocMap
	reff018ae0f.output_variable_count, coutput_variable_count_allocs = (C.uint32_t)(x.OutputVariableCount), cgoAllocsUnknown
	allocsf018ae0f.Borrow(coutput_variable_count_allocs)

	var coutput_variables_allocs *cgoAllocMap
	reff018ae0f.output_variables, coutput_variables_allocs = unpackSSInterfaceVariable(x.OutputVariables)
	allocsf018ae0f.Borrow(coutput_variables_allocs)

	var cinterface_variable_count_allocs *cgoAllocMap
	reff018ae0f.interface_variable_count, cinterface_variable_count_allocs = (C.uint32_t)(x.InterfaceVariableCount), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cinterface_variable_count_allocs)

	var cinterface_variables_allocs *cgoAllocMap
	reff018ae0f.interface_variables, cinterface_variables_allocs = unpackSInterfaceVariable(x.InterfaceVariables)
	allocsf018ae0f.Borrow(cinterface_variables_allocs)

	var cdescriptor_set_count_allocs *cgoAllocMap
	reff018ae0f.descriptor_set_count, cdescriptor_set_count_allocs = (C.uint32_t)(x.DescriptorSetCount), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cdescriptor_set_count_allocs)

	var cdescriptor_sets_allocs *cgoAllocMap
	reff018ae0f.descriptor_sets, cdescriptor_sets_allocs = unpackSDescriptorSet(x.DescriptorSets)
	allocsf018ae0f.Borrow(cdescriptor_sets_allocs)

	var cused_uniform_count_allocs *cgoAllocMap
	reff018ae0f.used_uniform_count, cused_uniform_count_allocs = (C.uint32_t)(x.UsedUniformCount), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cused_uniform_count_allocs)

	var cused_uniforms_allocs *cgoAllocMap
	reff018ae0f.used_uniforms, cused_uniforms_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.UsedUniforms)).Data)), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cused_uniforms_allocs)

	var cused_push_constant_count_allocs *cgoAllocMap
	reff018ae0f.used_push_constant_count, cused_push_constant_count_allocs = (C.uint32_t)(x.UsedPushConstantCount), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cused_push_constant_count_allocs)

	var cused_push_constants_allocs *cgoAllocMap
	reff018ae0f.used_push_constants, cused_push_constants_allocs = (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.UsedPushConstants)).Data)), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cused_push_constants_allocs)

	var cexecution_mode_count_allocs *cgoAllocMap
	reff018ae0f.execution_mode_count, cexecution_mode_count_allocs = (C.uint32_t)(x.ExecutionModeCount), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cexecution_mode_count_allocs)

	var cexecution_modes_allocs *cgoAllocMap
	reff018ae0f.execution_modes, cexecution_modes_allocs = (*C.SpvExecutionMode)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.ExecutionModes)).Data)), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cexecution_modes_allocs)

	var cinvocations_allocs *cgoAllocMap
	reff018ae0f.invocations, cinvocations_allocs = (C.uint32_t)(x.Invocations), cgoAllocsUnknown
	allocsf018ae0f.Borrow(cinvocations_allocs)

	var coutput_vertices_allocs *cgoAllocMap
	reff018ae0f.output_vertices, coutput_vertices_allocs = (C.uint32_t)(x.OutputVertices), cgoAllocsUnknown
	allocsf018ae0f.Borrow(coutput_vertices_allocs)

	x.reff018ae0f = reff018ae0f
	x.allocsf018ae0f = allocsf018ae0f
	return reff018ae0f, allocsf018ae0f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EntryPoint) PassValue() (C.SpvReflectEntryPoint, *cgoAllocMap) {
	if x.reff018ae0f != nil {
		return *x.reff018ae0f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EntryPoint) Deref() {
	if x.reff018ae0f == nil {
		return
	}
	x.Name = packPCharString(x.reff018ae0f.name)
	x.Id = (uint32)(x.reff018ae0f.id)
	x.SpirvExecutionModel = (ExecutionModel)(x.reff018ae0f.spirv_execution_model)
	x.ShaderStage = (ShaderStageFlagBits)(x.reff018ae0f.shader_stage)
	x.InputVariableCount = (uint32)(x.reff018ae0f.input_variable_count)
	packSSInterfaceVariable(x.InputVariables, x.reff018ae0f.input_variables)
	x.OutputVariableCount = (uint32)(x.reff018ae0f.output_variable_count)
	packSSInterfaceVariable(x.OutputVariables, x.reff018ae0f.output_variables)
	x.InterfaceVariableCount = (uint32)(x.reff018ae0f.interface_variable_count)
	packSInterfaceVariable(x.InterfaceVariables, x.reff018ae0f.interface_variables)
	x.DescriptorSetCount = (uint32)(x.reff018ae0f.descriptor_set_count)
	packSDescriptorSet(x.DescriptorSets, x.reff018ae0f.descriptor_sets)
	x.UsedUniformCount = (uint32)(x.reff018ae0f.used_uniform_count)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.UsedUniforms))
	hxf95e7c8.Data = unsafe.Pointer(x.reff018ae0f.used_uniforms)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.UsedPushConstantCount = (uint32)(x.reff018ae0f.used_push_constant_count)
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.UsedPushConstants))
	hxff2234b.Data = unsafe.Pointer(x.reff018ae0f.used_push_constants)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.ExecutionModeCount = (uint32)(x.reff018ae0f.execution_mode_count)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.ExecutionModes))
	hxff73280.Data = unsafe.Pointer(x.reff018ae0f.execution_modes)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.Invocations = (uint32)(x.reff018ae0f.invocations)
	x.OutputVertices = (uint32)(x.reff018ae0f.output_vertices)
}

// allocCapabilityInfoMemory allocates memory for type C.SpvReflectCapability in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCapabilityInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCapabilityInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCapabilityInfoValue = unsafe.Sizeof([1]C.SpvReflectCapability{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CapabilityInfo) Ref() *C.SpvReflectCapability {
	if x == nil {
		return nil
	}
	return x.refe9ca9817
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CapabilityInfo) Free() {
	if x != nil && x.allocse9ca9817 != nil {
		x.allocse9ca9817.(*cgoAllocMap).Free()
		x.refe9ca9817 = nil
	}
}

// NewCapabilityInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCapabilityInfoRef(ref unsafe.Pointer) *CapabilityInfo {
	if ref == nil {
		return nil
	}
	obj := new(CapabilityInfo)
	obj.refe9ca9817 = (*C.SpvReflectCapability)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CapabilityInfo) PassRef() (*C.SpvReflectCapability, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe9ca9817 != nil {
		return x.refe9ca9817, nil
	}
	meme9ca9817 := allocCapabilityInfoMemory(1)
	refe9ca9817 := (*C.SpvReflectCapability)(meme9ca9817)
	allocse9ca9817 := new(cgoAllocMap)
	allocse9ca9817.Add(meme9ca9817)

	var cvalue_allocs *cgoAllocMap
	refe9ca9817.value, cvalue_allocs = (C.SpvCapability)(x.Value), cgoAllocsUnknown
	allocse9ca9817.Borrow(cvalue_allocs)

	var cword_offset_allocs *cgoAllocMap
	refe9ca9817.word_offset, cword_offset_allocs = (C.uint32_t)(x.WordOffset), cgoAllocsUnknown
	allocse9ca9817.Borrow(cword_offset_allocs)

	x.refe9ca9817 = refe9ca9817
	x.allocse9ca9817 = allocse9ca9817
	return refe9ca9817, allocse9ca9817

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CapabilityInfo) PassValue() (C.SpvReflectCapability, *cgoAllocMap) {
	if x.refe9ca9817 != nil {
		return *x.refe9ca9817, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CapabilityInfo) Deref() {
	if x.refe9ca9817 == nil {
		return
	}
	x.Value = (Capability)(x.refe9ca9817.value)
	x.WordOffset = (uint32)(x.refe9ca9817.word_offset)
}

// allocSpecializationConstantMemory allocates memory for type C.SpvReflectSpecializationConstant in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationConstantMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationConstantValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSpecializationConstantValue = unsafe.Sizeof([1]C.SpvReflectSpecializationConstant{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SpecializationConstant) Ref() *C.SpvReflectSpecializationConstant {
	if x == nil {
		return nil
	}
	return x.ref8a46bef0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SpecializationConstant) Free() {
	if x != nil && x.allocs8a46bef0 != nil {
		x.allocs8a46bef0.(*cgoAllocMap).Free()
		x.ref8a46bef0 = nil
	}
}

// NewSpecializationConstantRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSpecializationConstantRef(ref unsafe.Pointer) *SpecializationConstant {
	if ref == nil {
		return nil
	}
	obj := new(SpecializationConstant)
	obj.ref8a46bef0 = (*C.SpvReflectSpecializationConstant)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SpecializationConstant) PassRef() (*C.SpvReflectSpecializationConstant, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8a46bef0 != nil {
		return x.ref8a46bef0, nil
	}
	mem8a46bef0 := allocSpecializationConstantMemory(1)
	ref8a46bef0 := (*C.SpvReflectSpecializationConstant)(mem8a46bef0)
	allocs8a46bef0 := new(cgoAllocMap)
	allocs8a46bef0.Add(mem8a46bef0)

	var cspirv_id_allocs *cgoAllocMap
	ref8a46bef0.spirv_id, cspirv_id_allocs = (C.uint32_t)(x.SpirvId), cgoAllocsUnknown
	allocs8a46bef0.Borrow(cspirv_id_allocs)

	var cconstant_id_allocs *cgoAllocMap
	ref8a46bef0.constant_id, cconstant_id_allocs = (C.uint32_t)(x.ConstantId), cgoAllocsUnknown
	allocs8a46bef0.Borrow(cconstant_id_allocs)

	var cname_allocs *cgoAllocMap
	ref8a46bef0.name, cname_allocs = unpackPCharString(x.Name)
	allocs8a46bef0.Borrow(cname_allocs)

	var ctype_description_allocs *cgoAllocMap
	ref8a46bef0.type_description, ctype_description_allocs = unpackSTypeDescription(x.TypeDescription)
	allocs8a46bef0.Borrow(ctype_description_allocs)

	var cdefault_value_size_allocs *cgoAllocMap
	ref8a46bef0.default_value_size, cdefault_value_size_allocs = (C.uint32_t)(x.DefaultValueSize), cgoAllocsUnknown
	allocs8a46bef0.Borrow(cdefault_value_size_allocs)

	var cdefault_value_allocs *cgoAllocMap
	ref8a46bef0.default_value, cdefault_value_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.DefaultValue)), cgoAllocsUnknown
	allocs8a46bef0.Borrow(cdefault_value_allocs)

	x.ref8a46bef0 = ref8a46bef0
	x.allocs8a46bef0 = allocs8a46bef0
	return ref8a46bef0, allocs8a46bef0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SpecializationConstant) PassValue() (C.SpvReflectSpecializationConstant, *cgoAllocMap) {
	if x.ref8a46bef0 != nil {
		return *x.ref8a46bef0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SpecializationConstant) Deref() {
	if x.ref8a46bef0 == nil {
		return
	}
	x.SpirvId = (uint32)(x.ref8a46bef0.spirv_id)
	x.ConstantId = (uint32)(x.ref8a46bef0.constant_id)
	x.Name = packPCharString(x.ref8a46bef0.name)
	packSTypeDescription(x.TypeDescription, x.ref8a46bef0.type_description)
	x.DefaultValueSize = (uint32)(x.ref8a46bef0.default_value_size)
	x.DefaultValue = (unsafe.Pointer)(unsafe.Pointer(x.ref8a46bef0.default_value))
}

// allocShaderModuleMemory allocates memory for type C.SpvReflectShaderModule in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderModuleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderModuleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderModuleValue = unsafe.Sizeof([1]C.SpvReflectShaderModule{})

// unpackSEntryPoint transforms a sliced Go data structure into plain C format.
func unpackSEntryPoint(x []EntryPoint) (unpacked *C.SpvReflectEntryPoint, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.SpvReflectEntryPoint) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocEntryPointMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.SpvReflectEntryPoint)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.SpvReflectEntryPoint)(h.Data)
	return
}

// unpackSCapabilityInfo transforms a sliced Go data structure into plain C format.
func unpackSCapabilityInfo(x []CapabilityInfo) (unpacked *C.SpvReflectCapability, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.SpvReflectCapability) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCapabilityInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.SpvReflectCapability)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.SpvReflectCapability)(h.Data)
	return
}

// allocA64DescriptorSetMemory allocates memory for type [64]C.SpvReflectDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA64DescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA64DescriptorSetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA64DescriptorSetValue = unsafe.Sizeof([1][64]C.SpvReflectDescriptorSet{})

// unpackA64DescriptorSet transforms a sliced Go data structure into plain C format.
func unpackA64DescriptorSet(x [64]DescriptorSet) (unpacked [64]C.SpvReflectDescriptorSet, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[64]C.SpvReflectDescriptorSet) {
		go allocs.Free()
	})

	mem0 := allocA64DescriptorSetMemory(1)
	allocs.Add(mem0)
	v0 := (*[64]C.SpvReflectDescriptorSet)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[64]C.SpvReflectDescriptorSet)(mem0)
	return
}

// unpackSSpecializationConstant transforms a sliced Go data structure into plain C format.
func unpackSSpecializationConstant(x []SpecializationConstant) (unpacked *C.SpvReflectSpecializationConstant, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.SpvReflectSpecializationConstant) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSpecializationConstantMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.SpvReflectSpecializationConstant)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.SpvReflectSpecializationConstant)(h.Data)
	return
}

// packSEntryPoint reads sliced Go data structure out from plain C format.
func packSEntryPoint(v []EntryPoint, ptr0 *C.SpvReflectEntryPoint) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfEntryPointValue]C.SpvReflectEntryPoint)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewEntryPointRef(unsafe.Pointer(&ptr1))
	}
}

// packSCapabilityInfo reads sliced Go data structure out from plain C format.
func packSCapabilityInfo(v []CapabilityInfo, ptr0 *C.SpvReflectCapability) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCapabilityInfoValue]C.SpvReflectCapability)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCapabilityInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packA64DescriptorSet reads sliced Go data structure out from plain C format.
func packA64DescriptorSet(v *[64]DescriptorSet, ptr0 *[64]C.SpvReflectDescriptorSet) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewDescriptorSetRef(unsafe.Pointer(&ptr1))
	}
}

// packSSpecializationConstant reads sliced Go data structure out from plain C format.
func packSSpecializationConstant(v []SpecializationConstant, ptr0 *C.SpvReflectSpecializationConstant) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSpecializationConstantValue]C.SpvReflectSpecializationConstant)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSpecializationConstantRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderModule) Ref() *C.SpvReflectShaderModule {
	if x == nil {
		return nil
	}
	return x.refce1fe5ac
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderModule) Free() {
	if x != nil && x.allocsce1fe5ac != nil {
		x.allocsce1fe5ac.(*cgoAllocMap).Free()
		x.refce1fe5ac = nil
	}
}

// NewShaderModuleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderModuleRef(ref unsafe.Pointer) *ShaderModule {
	if ref == nil {
		return nil
	}
	obj := new(ShaderModule)
	obj.refce1fe5ac = (*C.SpvReflectShaderModule)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderModule) PassRef() (*C.SpvReflectShaderModule, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce1fe5ac != nil {
		return x.refce1fe5ac, nil
	}
	memce1fe5ac := allocShaderModuleMemory(1)
	refce1fe5ac := (*C.SpvReflectShaderModule)(memce1fe5ac)
	allocsce1fe5ac := new(cgoAllocMap)
	allocsce1fe5ac.Add(memce1fe5ac)

	var cgenerator_allocs *cgoAllocMap
	refce1fe5ac.generator, cgenerator_allocs = (C.SpvReflectGenerator)(x.Generator), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(cgenerator_allocs)

	var centry_point_name_allocs *cgoAllocMap
	refce1fe5ac.entry_point_name, centry_point_name_allocs = unpackPCharString(x.EntryPointName)
	allocsce1fe5ac.Borrow(centry_point_name_allocs)

	var centry_point_id_allocs *cgoAllocMap
	refce1fe5ac.entry_point_id, centry_point_id_allocs = (C.uint32_t)(x.EntryPointId), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(centry_point_id_allocs)

	var centry_point_count_allocs *cgoAllocMap
	refce1fe5ac.entry_point_count, centry_point_count_allocs = (C.uint32_t)(x.EntryPointCount), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(centry_point_count_allocs)

	var centry_points_allocs *cgoAllocMap
	refce1fe5ac.entry_points, centry_points_allocs = unpackSEntryPoint(x.EntryPoints)
	allocsce1fe5ac.Borrow(centry_points_allocs)

	var csource_language_allocs *cgoAllocMap
	refce1fe5ac.source_language, csource_language_allocs = (C.SpvSourceLanguage)(x.SourceLanguage), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(csource_language_allocs)

	var csource_language_version_allocs *cgoAllocMap
	refce1fe5ac.source_language_version, csource_language_version_allocs = (C.uint32_t)(x.SourceLanguageVersion), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(csource_language_version_allocs)

	var csource_file_allocs *cgoAllocMap
	refce1fe5ac.source_file, csource_file_allocs = unpackPCharString(x.SourceFile)
	allocsce1fe5ac.Borrow(csource_file_allocs)

	var csource_source_allocs *cgoAllocMap
	refce1fe5ac.source_source, csource_source_allocs = unpackPCharString(x.SourceSource)
	allocsce1fe5ac.Borrow(csource_source_allocs)

	var ccapability_count_allocs *cgoAllocMap
	refce1fe5ac.capability_count, ccapability_count_allocs = (C.uint32_t)(x.CapabilityCount), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(ccapability_count_allocs)

	var ccapabilities_allocs *cgoAllocMap
	refce1fe5ac.capabilities, ccapabilities_allocs = unpackSCapabilityInfo(x.Capabilities)
	allocsce1fe5ac.Borrow(ccapabilities_allocs)

	var cspirv_execution_model_allocs *cgoAllocMap
	refce1fe5ac.spirv_execution_model, cspirv_execution_model_allocs = (C.SpvExecutionModel)(x.SpirvExecutionModel), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(cspirv_execution_model_allocs)

	var cshader_stage_allocs *cgoAllocMap
	refce1fe5ac.shader_stage, cshader_stage_allocs = (C.SpvReflectShaderStageFlagBits)(x.ShaderStage), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(cshader_stage_allocs)

	var cdescriptor_binding_count_allocs *cgoAllocMap
	refce1fe5ac.descriptor_binding_count, cdescriptor_binding_count_allocs = (C.uint32_t)(x.DescriptorBindingCount), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(cdescriptor_binding_count_allocs)

	var cdescriptor_bindings_allocs *cgoAllocMap
	refce1fe5ac.descriptor_bindings, cdescriptor_bindings_allocs = unpackSDescriptorBinding(x.DescriptorBindings)
	allocsce1fe5ac.Borrow(cdescriptor_bindings_allocs)

	var cdescriptor_set_count_allocs *cgoAllocMap
	refce1fe5ac.descriptor_set_count, cdescriptor_set_count_allocs = (C.uint32_t)(x.DescriptorSetCount), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(cdescriptor_set_count_allocs)

	var cdescriptor_sets_allocs *cgoAllocMap
	refce1fe5ac.descriptor_sets, cdescriptor_sets_allocs = unpackA64DescriptorSet(x.DescriptorSets)
	allocsce1fe5ac.Borrow(cdescriptor_sets_allocs)

	var cinput_variable_count_allocs *cgoAllocMap
	refce1fe5ac.input_variable_count, cinput_variable_count_allocs = (C.uint32_t)(x.InputVariableCount), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(cinput_variable_count_allocs)

	var cinput_variables_allocs *cgoAllocMap
	refce1fe5ac.input_variables, cinput_variables_allocs = unpackSSInterfaceVariable(x.InputVariables)
	allocsce1fe5ac.Borrow(cinput_variables_allocs)

	var coutput_variable_count_allocs *cgoAllocMap
	refce1fe5ac.output_variable_count, coutput_variable_count_allocs = (C.uint32_t)(x.OutputVariableCount), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(coutput_variable_count_allocs)

	var coutput_variables_allocs *cgoAllocMap
	refce1fe5ac.output_variables, coutput_variables_allocs = unpackSSInterfaceVariable(x.OutputVariables)
	allocsce1fe5ac.Borrow(coutput_variables_allocs)

	var cinterface_variable_count_allocs *cgoAllocMap
	refce1fe5ac.interface_variable_count, cinterface_variable_count_allocs = (C.uint32_t)(x.InterfaceVariableCount), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(cinterface_variable_count_allocs)

	var cinterface_variables_allocs *cgoAllocMap
	refce1fe5ac.interface_variables, cinterface_variables_allocs = unpackSInterfaceVariable(x.InterfaceVariables)
	allocsce1fe5ac.Borrow(cinterface_variables_allocs)

	var cpush_constant_block_count_allocs *cgoAllocMap
	refce1fe5ac.push_constant_block_count, cpush_constant_block_count_allocs = (C.uint32_t)(x.PushConstantBlockCount), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(cpush_constant_block_count_allocs)

	var cpush_constant_blocks_allocs *cgoAllocMap
	refce1fe5ac.push_constant_blocks, cpush_constant_blocks_allocs = unpackSBlockVariable(x.PushConstantBlocks)
	allocsce1fe5ac.Borrow(cpush_constant_blocks_allocs)

	var cspec_constant_count_allocs *cgoAllocMap
	refce1fe5ac.spec_constant_count, cspec_constant_count_allocs = (C.uint32_t)(x.SpecConstantCount), cgoAllocsUnknown
	allocsce1fe5ac.Borrow(cspec_constant_count_allocs)

	var cspec_constants_allocs *cgoAllocMap
	refce1fe5ac.spec_constants, cspec_constants_allocs = unpackSSpecializationConstant(x.SpecConstants)
	allocsce1fe5ac.Borrow(cspec_constants_allocs)

	x.refce1fe5ac = refce1fe5ac
	x.allocsce1fe5ac = allocsce1fe5ac
	return refce1fe5ac, allocsce1fe5ac

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderModule) PassValue() (C.SpvReflectShaderModule, *cgoAllocMap) {
	if x.refce1fe5ac != nil {
		return *x.refce1fe5ac, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderModule) Deref() {
	if x.refce1fe5ac == nil {
		return
	}
	x.Generator = (Generator)(x.refce1fe5ac.generator)
	x.EntryPointName = packPCharString(x.refce1fe5ac.entry_point_name)
	x.EntryPointId = (uint32)(x.refce1fe5ac.entry_point_id)
	x.EntryPointCount = (uint32)(x.refce1fe5ac.entry_point_count)
	packSEntryPoint(x.EntryPoints, x.refce1fe5ac.entry_points)
	x.SourceLanguage = (SourceLanguage)(x.refce1fe5ac.source_language)
	x.SourceLanguageVersion = (uint32)(x.refce1fe5ac.source_language_version)
	x.SourceFile = packPCharString(x.refce1fe5ac.source_file)
	x.SourceSource = packPCharString(x.refce1fe5ac.source_source)
	x.CapabilityCount = (uint32)(x.refce1fe5ac.capability_count)
	packSCapabilityInfo(x.Capabilities, x.refce1fe5ac.capabilities)
	x.SpirvExecutionModel = (ExecutionModel)(x.refce1fe5ac.spirv_execution_model)
	x.ShaderStage = (ShaderStageFlagBits)(x.refce1fe5ac.shader_stage)
	x.DescriptorBindingCount = (uint32)(x.refce1fe5ac.descriptor_binding_count)
	packSDescriptorBinding(x.DescriptorBindings, x.refce1fe5ac.descriptor_bindings)
	x.DescriptorSetCount = (uint32)(x.refce1fe5ac.descriptor_set_count)
	packA64DescriptorSet(&x.DescriptorSets, (*[64]C.SpvReflectDescriptorSet)(unsafe.Pointer(&x.refce1fe5ac.descriptor_sets)))
	x.InputVariableCount = (uint32)(x.refce1fe5ac.input_variable_count)
	packSSInterfaceVariable(x.InputVariables, x.refce1fe5ac.input_variables)
	x.OutputVariableCount = (uint32)(x.refce1fe5ac.output_variable_count)
	packSSInterfaceVariable(x.OutputVariables, x.refce1fe5ac.output_variables)
	x.InterfaceVariableCount = (uint32)(x.refce1fe5ac.interface_variable_count)
	packSInterfaceVariable(x.InterfaceVariables, x.refce1fe5ac.interface_variables)
	x.PushConstantBlockCount = (uint32)(x.refce1fe5ac.push_constant_block_count)
	packSBlockVariable(x.PushConstantBlocks, x.refce1fe5ac.push_constant_blocks)
	x.SpecConstantCount = (uint32)(x.refce1fe5ac.spec_constant_count)
	packSSpecializationConstant(x.SpecConstants, x.refce1fe5ac.spec_constants)
}

// unpackArgSShaderModule transforms a sliced Go data structure into plain C format.
func unpackArgSShaderModule(x []ShaderModule) (unpacked *C.SpvReflectShaderModule, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.SpvReflectShaderModule) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocShaderModuleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.SpvReflectShaderModule)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.SpvReflectShaderModule)(h.Data)
	return
}

// packSShaderModule reads sliced Go data structure out from plain C format.
func packSShaderModule(v []ShaderModule, ptr0 *C.SpvReflectShaderModule) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfShaderModuleValue]C.SpvReflectShaderModule)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewShaderModuleRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPDescriptorBinding transforms a sliced Go data structure into plain C format.
func unpackArgSPDescriptorBinding(x []*DescriptorBinding) (unpacked **C.SpvReflectDescriptorBinding, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.SpvReflectDescriptorBinding) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPDescriptorBindingMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.SpvReflectDescriptorBinding)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassRef()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.SpvReflectDescriptorBinding)(h.Data)
	return
}

// packSPDescriptorBinding reads sliced Go data structure out from plain C format.
func packSPDescriptorBinding(v []*DescriptorBinding, ptr0 **C.SpvReflectDescriptorBinding) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.SpvReflectDescriptorBinding)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = NewDescriptorBindingRef(unsafe.Pointer(ptr1))
	}
}

// allocPDescriptorSetMemory allocates memory for type *C.SpvReflectDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDescriptorSetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDescriptorSetValue = unsafe.Sizeof([1]*C.SpvReflectDescriptorSet{})

// unpackArgSPDescriptorSet transforms a sliced Go data structure into plain C format.
func unpackArgSPDescriptorSet(x []*DescriptorSet) (unpacked **C.SpvReflectDescriptorSet, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.SpvReflectDescriptorSet) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPDescriptorSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.SpvReflectDescriptorSet)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassRef()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.SpvReflectDescriptorSet)(h.Data)
	return
}

// packSPDescriptorSet reads sliced Go data structure out from plain C format.
func packSPDescriptorSet(v []*DescriptorSet, ptr0 **C.SpvReflectDescriptorSet) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.SpvReflectDescriptorSet)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = NewDescriptorSetRef(unsafe.Pointer(ptr1))
	}
}

// unpackArgSPInterfaceVariable transforms a sliced Go data structure into plain C format.
func unpackArgSPInterfaceVariable(x []*InterfaceVariable) (unpacked **C.SpvReflectInterfaceVariable, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.SpvReflectInterfaceVariable) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPInterfaceVariableMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.SpvReflectInterfaceVariable)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassRef()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.SpvReflectInterfaceVariable)(h.Data)
	return
}

// packSPInterfaceVariable reads sliced Go data structure out from plain C format.
func packSPInterfaceVariable(v []*InterfaceVariable, ptr0 **C.SpvReflectInterfaceVariable) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.SpvReflectInterfaceVariable)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = NewInterfaceVariableRef(unsafe.Pointer(ptr1))
	}
}

// allocPBlockVariableMemory allocates memory for type *C.SpvReflectBlockVariable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPBlockVariableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPBlockVariableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPBlockVariableValue = unsafe.Sizeof([1]*C.SpvReflectBlockVariable{})

// unpackArgSPBlockVariable transforms a sliced Go data structure into plain C format.
func unpackArgSPBlockVariable(x []*BlockVariable) (unpacked **C.SpvReflectBlockVariable, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.SpvReflectBlockVariable) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPBlockVariableMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.SpvReflectBlockVariable)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassRef()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.SpvReflectBlockVariable)(h.Data)
	return
}

// packSPBlockVariable reads sliced Go data structure out from plain C format.
func packSPBlockVariable(v []*BlockVariable, ptr0 **C.SpvReflectBlockVariable) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.SpvReflectBlockVariable)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = NewBlockVariableRef(unsafe.Pointer(ptr1))
	}
}

// unpackArgSSBlockVariable transforms a sliced Go data structure into plain C format.
func unpackArgSSBlockVariable(x [][]BlockVariable) (unpacked **C.SpvReflectBlockVariable, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.SpvReflectBlockVariable) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPBlockVariableMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.SpvReflectBlockVariable)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocBlockVariableMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.SpvReflectBlockVariable)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.SpvReflectBlockVariable)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.SpvReflectBlockVariable)(h.Data)
	return
}

// packSSBlockVariable reads sliced Go data structure out from plain C format.
func packSSBlockVariable(v [][]BlockVariable, ptr0 **C.SpvReflectBlockVariable) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.SpvReflectBlockVariable)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfBlockVariableValue]C.SpvReflectBlockVariable)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewBlockVariableRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPSpecializationConstantMemory allocates memory for type *C.SpvReflectSpecializationConstant in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPSpecializationConstantMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPSpecializationConstantValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPSpecializationConstantValue = unsafe.Sizeof([1]*C.SpvReflectSpecializationConstant{})

// unpackArgSPSpecializationConstant transforms a sliced Go data structure into plain C format.
func unpackArgSPSpecializationConstant(x []*SpecializationConstant) (unpacked **C.SpvReflectSpecializationConstant, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.SpvReflectSpecializationConstant) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPSpecializationConstantMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.SpvReflectSpecializationConstant)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassRef()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.SpvReflectSpecializationConstant)(h.Data)
	return
}

// packSPSpecializationConstant reads sliced Go data structure out from plain C format.
func packSPSpecializationConstant(v []*SpecializationConstant, ptr0 **C.SpvReflectSpecializationConstant) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.SpvReflectSpecializationConstant)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = NewSpecializationConstantRef(unsafe.Pointer(ptr1))
	}
}

// unpackArgSDescriptorBinding transforms a sliced Go data structure into plain C format.
func unpackArgSDescriptorBinding(x []DescriptorBinding) (unpacked *C.SpvReflectDescriptorBinding, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.SpvReflectDescriptorBinding) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorBindingMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.SpvReflectDescriptorBinding)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.SpvReflectDescriptorBinding)(h.Data)
	return
}

// unpackArgSBlockVariable transforms a sliced Go data structure into plain C format.
func unpackArgSBlockVariable(x []BlockVariable) (unpacked *C.SpvReflectBlockVariable, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.SpvReflectBlockVariable) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBlockVariableMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.SpvReflectBlockVariable)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.SpvReflectBlockVariable)(h.Data)
	return
}
